import { z } from "zod";
import type { PluginContext } from "../context.js";
import { registerTool, success, error, executeBash } from "../helpers.js";

export function registerDocTools(ctx: PluginContext): void {
  const repoPath = () => ctx.config.documentation.repo_path;
  // Accept the calling tool's name so the error envelope's `tool` field matches the actual invocation.
  // Without this, all doc tools would return tool:"doc" which breaks the response envelope contract.
  const noRepo = (toolName: string) => error(toolName, ctx.targetHost, null, { code: "NO_DOC_REPO", category: "validation", message: "No documentation repo configured. Set documentation.repo_path in config.yaml.", remediation: ["Set documentation.repo_path in ~/.config/linux-sysadmin/config.yaml"] });

  registerTool(ctx, { name: "doc_status", description: "Show documentation repo status: git state, tracked hosts/services.", module: "docs", riskLevel: "read-only", duration: "quick", inputSchema: z.object({}), annotations: { readOnlyHint: true } }, async () => {
    const rp = repoPath();
    if (!rp) return noRepo("doc_status");
    const r = await executeBash(ctx, `cd '${rp}' && git status --short && echo '---HOSTS---' && ls -d hosts/*/ 2>/dev/null || echo 'No hosts documented'`, "quick");
    return success("doc_status", ctx.targetHost, r.durationMs, "git status + ls", { output: r.stdout.trim(), repo_path: rp });
  });

  registerTool(ctx, { name: "doc_init", description: "Initialize documentation git repo. Low risk.", module: "docs", riskLevel: "low", duration: "quick", inputSchema: z.object({ path: z.string().optional().describe("Override repo path") }), annotations: { destructiveHint: false } }, async (args) => {
    const rp = (args.path as string) ?? repoPath();
    if (!rp) return noRepo("doc_init");
    const cmd = `mkdir -p '${rp}' && cd '${rp}' && git init && mkdir -p hosts/${ctx.targetHost.replace(/[^a-zA-Z0-9.-]/g, "_")}/services && echo '# Infrastructure Documentation' > README.md && git add -A && git commit -m '${ctx.config.documentation.commit_prefix}: initialize documentation repo'`;
    const r = await executeBash(ctx, cmd, "quick");
    if (r.exitCode !== 0) return error("doc_init", ctx.targetHost, r.durationMs, { code: "COMMAND_FAILED", category: "state", message: r.stderr.trim() });
    return success("doc_init", ctx.targetHost, r.durationMs, cmd, { initialized: rp });
  });

  registerTool(ctx, { name: "doc_generate_host", description: "Generate/update host-level README with system overview.", module: "docs", riskLevel: "low", duration: "normal", inputSchema: z.object({ rationale: z.string().optional().describe("Why this host exists / its role") }), annotations: { destructiveHint: false } }, async (args) => {
    const rp = repoPath();
    if (!rp) return noRepo("doc_generate_host");
    const hostname = ctx.targetHost.replace(/[^a-zA-Z0-9.-]/g, "_");
    const hostDir = `${rp}/hosts/${hostname}`;
    // Gather system data
    const [osR, svcsR, pkgsR] = await Promise.all([
      executeBash(ctx, "cat /etc/os-release | head -5", "instant"),
      executeBash(ctx, "systemctl list-units --type=service --state=running --no-pager --no-legend | head -30", "quick"),
      executeBash(ctx, ctx.distro.family === "debian" ? "dpkg -l | wc -l" : "rpm -qa | wc -l", "quick"),
    ]);
    const activeProfiles = ctx.knowledgeBase.getActiveProfiles().map(p => p.profile.name).join(", ") || "none detected";
    const rationale = (args.rationale as string) ?? "[TODO: describe this host's purpose]";
    const readme = `# ${ctx.targetHost}

## Purpose
${rationale}

## System Info
- **Distro**: ${ctx.distro.name} ${ctx.distro.version}
- **Family**: ${ctx.distro.family}
- **Firewall**: ${ctx.distro.firewall_backend}
- **MAC**: ${ctx.distro.mac_system} (${ctx.distro.mac_mode ?? "n/a"})
- **Container Runtime**: ${ctx.distro.container_runtime}
- **Packages Installed**: ${pkgsR.stdout.trim()}

## Detected Services (Knowledge Profiles)
${activeProfiles}

## Running Services
\`\`\`
${svcsR.stdout.trim()}
\`\`\`

## OS Release
\`\`\`
${osR.stdout.trim()}
\`\`\`

---
*Generated by linux-sysadmin-mcp on ${new Date().toISOString()}*
`;
    const cmd = `mkdir -p '${hostDir}/services' && cat > '${hostDir}/README.md' << 'DOCEOF'\n${readme}\nDOCEOF`;
    const r = await executeBash(ctx, cmd, "quick");
    if (r.exitCode !== 0) return error("doc_generate_host", ctx.targetHost, r.durationMs, { code: "COMMAND_FAILED", category: "state", message: r.stderr.trim() });
    // Git commit
    await executeBash(ctx, `cd '${rp}' && git add -A && git commit -m '${ctx.config.documentation.commit_prefix}: update host README for ${hostname}' 2>/dev/null || true`, "quick");
    return success("doc_generate_host", ctx.targetHost, r.durationMs, "generate host README", { path: `${hostDir}/README.md` });
  });

  registerTool(ctx, { name: "doc_generate_service", description: "Generate/update per-service README using knowledge profile data.", module: "docs", riskLevel: "low", duration: "normal", inputSchema: z.object({ service: z.string().min(1), rationale: z.string().optional() }), annotations: { destructiveHint: false } }, async (args) => {
    const rp = repoPath();
    if (!rp) return noRepo("doc_generate_service");
    const svc = args.service as string;
    const hostname = ctx.targetHost.replace(/[^a-zA-Z0-9.-]/g, "_");
    const svcDir = `${rp}/hosts/${hostname}/services/${svc}`;
    const profile = ctx.knowledgeBase.getProfile(svc);
    const rationale = (args.rationale as string) ?? "[TODO: describe why this service runs here]";
    // Build README from profile + live data
    let readme = `# ${svc}\n\n## Purpose\n${rationale}\n\n`;
    if (profile) {
      readme += `## Configuration\n- **Primary config**: \`${profile.config.primary}\`\n`;
      if (profile.config.additional?.length) {
        readme += profile.config.additional.map(a => `- \`${a.path}\`: ${a.description}`).join("\n") + "\n";
      }
      if (profile.config.validate_command) readme += `- **Validate**: \`${profile.config.validate_command}\`\n`;
      if (profile.ports?.length) {
        readme += `\n## Ports\n` + profile.ports.map(p => `- **${p.port}/${p.protocol}** (${p.scope}): ${p.description}`).join("\n") + "\n";
      }
      if (profile.dependencies?.requires?.length) {
        readme += `\n## Dependencies\n` + profile.dependencies.requires.map(d => `- **${d.role}**: ${d.reason} (impact if down: ${d.impact_if_down})`).join("\n") + "\n";
      }
      if (profile.health_checks?.length) {
        readme += `\n## Health Checks\n` + profile.health_checks.map(h => `- \`${h.command}\`: ${h.description}`).join("\n") + "\n";
      }
      if (profile.troubleshooting?.length) {
        readme += `\n## Troubleshooting\n` + profile.troubleshooting.map(t => `### ${t.symptom}\n- Checks: ${t.checks.join(", ")}\n- Common causes: ${t.common_causes.join(", ")}`).join("\n\n") + "\n";
      }
    }
    readme += `\n---\n*Generated by linux-sysadmin-mcp on ${new Date().toISOString()}*\n`;
    const cmd = `mkdir -p '${svcDir}' && cat > '${svcDir}/README.md' << 'DOCEOF'\n${readme}\nDOCEOF`;
    const r = await executeBash(ctx, cmd, "quick");
    if (r.exitCode !== 0) return error("doc_generate_service", ctx.targetHost, r.durationMs, { code: "COMMAND_FAILED", category: "state", message: r.stderr.trim() });
    await executeBash(ctx, `cd '${rp}' && git add -A && git commit -m '${ctx.config.documentation.commit_prefix}: update service README for ${svc} on ${hostname}' 2>/dev/null || true`, "quick");
    return success("doc_generate_service", ctx.targetHost, r.durationMs, "generate service README", { path: `${svcDir}/README.md`, profile_used: !!profile });
  });

  registerTool(ctx, { name: "doc_backup_config", description: "Backup a service's config files to the documentation repo.", module: "docs", riskLevel: "read-only", duration: "quick", inputSchema: z.object({ service: z.string().min(1), paths: z.array(z.string()).optional().describe("Override config paths (uses profile if omitted)") }), annotations: { readOnlyHint: true } }, async (args) => {
    const rp = repoPath();
    if (!rp) return noRepo("doc_backup_config");
    const svc = args.service as string;
    const hostname = ctx.targetHost.replace(/[^a-zA-Z0-9.-]/g, "_");
    const backupDir = `${rp}/hosts/${hostname}/services/${svc}/configs`;
    const profile = ctx.knowledgeBase.getProfile(svc);
    const paths = (args.paths as string[] | undefined) ?? (profile ? [profile.config.primary, ...(profile.config.backup_paths ?? [])] : []);
    if (!paths.length) return error("doc_backup_config", ctx.targetHost, null, { code: "NO_PATHS", category: "validation", message: "No config paths to back up. Specify paths or ensure a knowledge profile exists." });
    const cmds = [`mkdir -p '${backupDir}'`];
    for (const p of paths) {
      const fname = p.replace(/\//g, "_").replace(/^_/, "");
      // Each cp attempt echoes a result line so we can parse backed_up vs skipped below.
      // Use SKIPPED_SENTINEL format so it's unambiguous in mixed stdout.
      cmds.push(`sudo -n cp '${p}' '${backupDir}/${fname}' 2>/dev/null && echo "BACKED_UP:${p}" || cp '${p}' '${backupDir}/${fname}' 2>/dev/null && echo "BACKED_UP:${p}" || echo "SKIPPED:${p}"`);
    }
    cmds.push(`cd '${rp}' && git add -A && git commit -m '${ctx.config.documentation.commit_prefix}: backup configs for ${svc} on ${hostname}' 2>/dev/null || true`);
    const r = await executeBash(ctx, cmds.join("; "), "quick");
    // Parse outcome lines to report accurate backed_up / skipped counts
    const backedUp = r.stdout.split("\n").filter((l) => l.startsWith("BACKED_UP:")).map((l) => l.slice(10));
    const skipped = r.stdout.split("\n").filter((l) => l.startsWith("SKIPPED:")).map((l) => l.slice(8));
    return success("doc_backup_config", ctx.targetHost, r.durationMs, "config backup", {
      backed_up: backedUp,
      backup_dir: backupDir,
      ...(skipped.length > 0 ? { skipped, skipped_reason: "File not readable or does not exist" } : {}),
    });
  });

  registerTool(ctx, { name: "doc_diff", description: "Show uncommitted documentation changes.", module: "docs", riskLevel: "read-only", duration: "quick", inputSchema: z.object({}), annotations: { readOnlyHint: true } }, async () => {
    const rp = repoPath();
    if (!rp) return noRepo("doc_diff");
    const r = await executeBash(ctx, `cd '${rp}' && git diff --stat && echo '---DIFF---' && git diff`, "quick");
    return success("doc_diff", ctx.targetHost, r.durationMs, "git diff", { output: r.stdout.trim() });
  });

  registerTool(ctx, { name: "doc_history", description: "Show documentation commit history.", module: "docs", riskLevel: "read-only", duration: "quick", inputSchema: z.object({ limit: z.number().int().min(1).max(50).optional().default(20) }), annotations: { readOnlyHint: true } }, async (args) => {
    const rp = repoPath();
    if (!rp) return noRepo("doc_history");
    const r = await executeBash(ctx, `cd '${rp}' && git log --oneline -n ${(args.limit as number) ?? 20}`, "quick");
    return success("doc_history", ctx.targetHost, r.durationMs, "git log", { history: r.stdout.trim() });
  });

  registerTool(ctx, { name: "doc_restore_guide", description: "Generate a disaster recovery / restore guide for a host.", module: "docs", riskLevel: "read-only", duration: "normal", inputSchema: z.object({}), annotations: { readOnlyHint: true } }, async () => {
    const rp = repoPath();
    if (!rp) return noRepo("doc_restore_guide");
    const hostname = ctx.targetHost.replace(/[^a-zA-Z0-9.-]/g, "_");
    const hostDir = `${rp}/hosts/${hostname}`;
    // Read existing docs
    const [hostR, svcsListR] = await Promise.all([
      executeBash(ctx, `cat '${hostDir}/README.md' 2>/dev/null || echo 'No host README'`, "quick"),
      executeBash(ctx, `ls '${hostDir}/services/' 2>/dev/null || echo 'none'`, "quick"),
    ]);
    const services = svcsListR.stdout.trim().split("\n").filter(s => s !== "none" && s.trim());
    // Build per-service structured restore entries from their READMEs
    const serviceEntries: Array<{ name: string; restore_steps: string[]; readme_available: boolean }> = [];
    for (const svc of services) {
      const r = await executeBash(ctx, `cat '${hostDir}/services/${svc}/README.md' 2>/dev/null`, "quick");
      const hasReadme = r.exitCode === 0 && r.stdout.trim().length > 0;
      serviceEntries.push({
        name: svc,
        restore_steps: hasReadme
          ? [`Install and configure ${svc} per its README`, `Restore config files from configs/ directory`, `Enable and start the service`, `Run health checks to verify`]
          : [`Install ${svc}`, `Restore configuration`, `Enable and start the service`],
        readme_available: hasReadme,
      });
    }
    const restoreSequence = [
      `Provision new host matching distro: ${ctx.distro.name} ${ctx.distro.version}`,
      "Restore config files from this repo's configs/ directories",
      "Install packages and enable services per each service README",
      "Verify health checks pass for each service",
    ];
    // Full guide markdown for human-readable output alongside the structured fields
    const svcDocsMarkdown = serviceEntries.map(s =>
      `### ${s.name}\n${s.restore_steps.map(step => `- ${step}`).join("\n")}`
    ).join("\n\n");
    const fullGuideMarkdown = `# Disaster Recovery Guide: ${ctx.targetHost}\n\n## Host Overview\n${hostR.stdout.trim()}\n\n## Services to Restore\n${svcDocsMarkdown}\n\n## Restore Steps\n${restoreSequence.map((s, i) => `${i + 1}. ${s}`).join("\n")}\n\n---\n*Generated ${new Date().toISOString()}*\n`;
    return success("doc_restore_guide", ctx.targetHost, null, null, {
      host_summary: hostR.stdout.trim(),
      services: serviceEntries,
      restore_sequence: restoreSequence,
      services_documented: services.length,
      generated_at: new Date().toISOString(),
      full_guide_markdown: fullGuideMarkdown,
    });
  });
}
